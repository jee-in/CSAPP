## 11. 3 글로벌 IP 인터넷

글로벌 IP 인터넷은 가장 유명하고 성공적인 인터넷의 구현물이다. 이는 1969년 이래로 여러 형태로 존재해왔다. 인터넷의 내부 구조가 복잡하고 지속적으로 변화하고 있는 반면, 클라이언트-서버 응용 프로그램의 구조는 초기 1980년대 이래로 상당히 변화 없이 유지되었다. 사진 11.8은 인터넷 클라이어트-서버 응용 프로그램의 기본 하드웨어와 소프트웨어 구조를 보여준다.  

각각의 인터넷 호스트는 TCP/IP 프로토콜 (Transmission Control Protocol/Internet Protocol)을 구현하는 소프트웨어를 운영한다. TCP/IP 프로토콜은 대부분의 모든 컴퓨터 시스템에 의해 지원된다. 인터넷 클라이언트와 서버는 소켓 인터페이스 sockets interface 함수와 UNIX I/O 함수를 섞어 사용하여 서로 소통한다. (우리는 소켓 인터페이스에 대해 11.4절에서 다룰 것이다.) 소켓 함수는 일반적으로 시스템 콜로 구현된다. 이 시스템 콜은 커널로 빠져 들어가서 TCP/IP에 있는 다양한 커널 모두 함수를 호출한다.  

TCP/IP는 사실 서로 다른 기능을 가지는 여러 프로토콜의 집합니다. 예를 들어, IP는 데이터그램 datagram이라고 알려진 패킷을 전송할 수 있는 전달 메커니즘과 기본 명명법 basic naming scheme을 하나의 인터넷 호스트에서 다른 호스트로 제공한다. IP 메커니즘은 데이터그램이 네트워크에서 손실되거나 복제됐을 때 그 데이터그램을 복구하기 위해 아무런 노력을 하지 않는다는 점에서 신뢰할 수 없는 unreliable 메커니즘이다. UDP (Unreliable Datagram Protocol)는 IP를 살짝 확장해서, 데이터그램이 호스트에서 호스트보다도, 프로세스에서 프로세스로 이동될 수 있도록 한 것이다. TCP는 프로세스 사이에 신뢰할 수 있는 reliable 완전한 duplex (bidirectional 양방향) 연결을 제공하기 위해 IP 위에서 구현된 복잡한 프로토콜이다. 우리의 논의를 간단하게 만들기 위해서, 우리는 TCP/IP를 하나의 monolithic한 프로토콜로 간주할 것이다. 우리는 TCP/IP의 내부 작동을 논의하지 않을 것이며, 우리는 TCP와 IP가 응용 프로그램에 제공하는 기본적인 기능 몇 가지만 다룰 것이다. 우리는 UDP에 대해 다루지 않을 것이다.  

개발자의 관점에서, 우리는 인터넷이 다음과 같은 속성을 가진 전세계적 호스트의 집합이라고 생각할 수 있다.

- 호스트는 32 비트 IP 주소에 매핑된다.
- IP 주소는 인터넷 도메인 네임이라고 불리는 식별자에 매핑된다.
- 하나의 인터넷 호스트에 있는 프로세스는 연결을 통해서 모든 다른 인터넷 호스트에 있는 프로세스와 통신할 수 있다.

다음 절에서는 이러한 기본적인 인터넷 아이디어들을 자세하게 다룰 것이다.

> IPv4 vs IPv6  
기존의 인터넷 프로토콜은 32 비트 주소를 가진 Internet Protocol Version 4(IPv4)이다. 1996년에 Internet Engineering Task Force (IETF)는 128 비트 주소를 가지면서 IPv4를 계승할 Internet Protocol Version 6(IPv6)라는 새로운 버전의 IP를 제안했다. 하지만 그로부터 20년이 지난 2015년 인터넷 트래픽의 대부분은 여전히 IPv4 네트워크에 의해 수행되고 있다. 예를 들어, 오직 4%의 사용자만이 IPv6를 사용하여 Google 서비스에 접근한다.  
이 책에서는 채택률이 낮은 IPv6에 대해 논의하지 않을 것이며 IPv4 이면의 개념들에 집중할 것이다. 우리가 인터넷에 대해 이야기할 때 인터넷이 의미하는 것은 IPv4에 기반을 둔 인터넷이다. 그럼에도 불구하고, 클라이언트와 서버를 작성하는 기술들은 프로토콜에 독립적인 현대 인터페이스들에 기반을 두고 있다. 

### 11.3.1 IP 주소

IP 주소는 부호가 없는 32 비트 정수이다. 네트워크 프로그램은 IP 주소 구조체에 IP 주소를 저장한다.  
구조체에 scalar 주소를 저장하는 것은 초기 소켓 인터페이스의 구현물에서 온 운이 좋지 않은 산물이다. IP 주소를 위한 scalar 타입을 정의하는 것이 사실 더 자연스럽다. 하지만 이미 설치된 응용 프로그램의 베이스(?) base가 너무 거대하기 때문에 이제 와서 바꾸기에는 너무 늦었다.  

인터넷 호스트들이 서로 다른 호스트 바이트 순서를 가질 수 있기 때문에, TCP/IP는 모든 정수 데이터 아이템, 예를 들면 패킷 헤더 안에 담겨 네트워크를 건너는 IP 주소,에 대해서 통일된 네트워크 바이트 순서(빅 엔디언 big-endian 바이트 순서)를 정의한다 IP 주소 구조체에 있는 주소들은 호스트 바이트 순서가 리틀 엔디안 little endian일지라도 항상 (빅 엔디안) 네트워크 바이트 순서로 저장된다. 유닉스는 네트워크와 호스트 바이트 순서 간에 변환을 하기 위해 다음과 같은 함수를 제공한다. 

- htonl 함수  
부호가 없는 32 비트 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환한다. 
- ntohl 함수  
부호가 없는 32 비트 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환한다.
- htons 함수
부호가 없는 16 비트 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환한다. 
- ntohs 함수
부호가 없는 16 비트 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환한다. 

64 비트 값을 조작하는 동일한 함수는 없다.  

IP 주소는 일반적으로 인간에게 dotted-decimal notation이라고 알려진 형식으로 표현된다. dotted-decimal notation은 각 바이트가 10진수로 표현되고 다른 바이트들과 점으로 구분되는 표기법이다. 예를 들어, `128.2.194.242`는 주소 `0x8002c2f2`의 dotted-decimal 표현이다. 리눅스 시스템에서 당신은 당신이 소유한 호스트의 dotted-decimal 주소를 알아내기 determine 위해 HOSTNAME 명령어를 사용할 수 있다.

```
linux> hostname -i
```

응용 프로그램은 IP 주소와 dotted-decimal 문자열 사이를 왔다갔다 변환할 수 있다. 이때 사용하는 함수는 inet_pton과 inet_ntop이다.

이러한 함수들에서, "n"은 network를 나타내고, "p"는 표현을 나타낸다. 이 함수들은 32 비트 IPv4 주소를 다룰 수도 있고(AF_INET), 128 비트 IPv6 주소를 다룰 수도 있다(AF_INET6).  

inet_pton 함수는 dotted-decimal 문자열(src)를 네트워크 바이트 순서(dst)로 이진 IP 주소로 변환한다. 만약 src가 유효한 dotted-decimal 문자열을 가리키지 않는다면 0을 반환한다. 다른 에러가 있다면 -1을 반환하고 errno를 설정한다. 비슷하게, inet_ntop 함수는 이진 IP 주소를 네트워크 바이트 순서로 dotted_decimal 표현으로 변환하고 NULL로 끝나는 dotted-decimal 스트링의 최대 size 바이트를 dst로 복사한다.

### 11.3.2 인터넷 도메인 이름 Internet Domain Names

인터넷 클라이언트와 서버는 서로 서통할 때 IP 주소를 사용한다. 하지만, 큰 정수는 사람들이 기억하기 어렵기 때문에 인터넷은 인간 최화적인 도메인 이름 domain names를 별도로 정의한다. 도메인 이름과 IP 주소를 매핑하는 메커니즘도 정의한다. 도메인 이름은 점으로 구분된 단어(문자, 숫자, dash)의 sequence이다.(<예시> waleshark.ics.cs.cmu.edu.)  

도메인 이름은 계층을 이루고, 각각의 도메인 이름은 계층에서의 위치를 인코딩한다.  

계층은 트리처럼 표현된다. 각각의 트리의 노드들은 루트로 향하는 길에 의해 형성되는(?) 도메인 이름을 나타낸다. 서브 트리들은 서브 도메인이라고 불린다. 계층 구조의 첫 번째 레벨은 이름이 붙지 않은 루트 노드이다. 그 다음 레벨은 첫 번째 레벨의 도메인 이름의 집합이다. 도메인 이름은 비영리기관인 ICANN (Internet Corporation for Assigned NAmes and Numbers)에 의해 정의되었다. 잘 알려진 첫 번째 레벨 도메인으로는 com, edu, gov, net이 있다.   

다음 레벨은 두 번째 레벨 도메인 이름이다. 예를 들면, cmu.edu와 같은 것들이다. 
두 번째 레벨 도메인 이름들은 요청한 순서대로 다양한 인증받은 ICANN의 대행사에 의해 할당된다.

어떤 기관이 두 번째 레벨의 도메인 이름을 받았다면 그 서브 도메인 안에서 다른 어떤 새로운 도메인 이름을 만들든지 모두 무료이다. 예를 들면 cs.cmu.edu와 같은 식이다.  

인터넷은 도메인 이름과 IP 주소 사이의 매핑을 정의한다. 1988년까지 이 매핑은 HOSTS.TXT라는 하나의 텍스트 파일에 수동으로 관리되엇다. 그때 이후로는 매핑은 분산된 전세계적 데이터 베이스 DNS (domain Name System)에서 관리되어 왔다. 개념적으로 DNS 데이터베이스는 수백만의 호스트 항목으로 이루어져 있다. 호스트 항목은 도메인 이름과 IP 주소 사이를 매핑한다. 수학적으로 말했을 때, 각각의 항목을 도메인 이름과 IP 주소의 equivalent 클래스로 생각할 수 있다. 우리는 리눅스의 `NSLOOKUP` 프로그램으로 DNS 매핑의 몇몇 속성을 탐험해볼 것이다. 이 프로그램은 도메인 이름과 함께 IP 주소를 보여준다.  

각각의 인터넷 호스트는 지역적으로 정의된 도메인 이름 `localhost`를 가지고 있다. 이는 항상 루프백 주소인 `127.0.0.1`로 매핑되어 있다.

localhost 이름은 같은 머신에서 돌아가고 있는 클라이언트와 서버를 참조할 수 있는 편리하고 portable한 방법을 제공한다. 이 방법은 특히 디버깅 시에 유용하다. 

우리는 우리 로컬 호스트의 진짜 도메인 이름을 알아내기 위해 `HOSTNAME`을 사용한다. 

가장 간단한 경우에, 도메인 이름과 IP 주소 사이에는 하나의 매핑만 잇다. 하지만 어떤ㄷ 경우에는 다수의 도메인 이름이 하나의 IP에 매핑되기도 한다. 가장 일반적인 경우에는 다수의 도메인 이름이 다수의 동일한 IP 주소를 가리킨다.

> nslookup www.twitter.com / nslookup twitter.com

마지막으로 어떤 유효한 도메인 이름은 아무 IP 주소에도 매핑되어 있지 않다. 

> 인터넷 호스트는 얼마나 많이 존재하는가?  
1987년 이래로 Internet Systems Consortium은 일 년에 두 번 Intenet Domain Survey를 수행한다. 이 survey는 도메인 이름을 배정받은 IP 주소의 수를 집계함으로써 인터넷 호스트의 수를 추정하는데, 이 조사는 놀라운 추세를 보여준다. 인터넷 호스트가 약 20,000개 있었던 1987년 이래로 호스트의 수는 기하급수적으로 증가하였다. 2015년까지 10억 개가 넘는 인터넷 호스트가 있는 것으로 알려졌다.

### 11.3.3 인터넷 연결 

인터넷 클라이언트와 서버는 연결을 통해 바이트 스트림을 전송하고 수신함으로써 통신한다. 연결은 두 프로세스를 연결한다는 점에서 연결은 point-to-point 연결이다. 연결은 데이터가 양방향으로 같은 시간에 흐를 수 있다는 점에서 완전 양방향 full-duplex이다. 또한 연결은 소스 프로세스로부터 전송된 바이트 스트림이 마침내 목적지 프로세스에 의해 수신된다는 점에서 신뢰할 수 있다. 몇 가지 예상치 못한 극단적인 재앙적인 실패를 감안하더라도 말이다.  

소켓 socket은 연결의 마지막 포인트 end point이다. 각각의 소켓은 대응되는 소켓 주소 socket address를 가진다. socket address는 인터넷 주소와 16 비트 정수 포트(이 소프트웨어 포트들은 네트워크 스위치와 라우터에 있는 하드웨어 포트와 전혀 관계가 없다.)를 가지고 `address:port` 표기법으로 나타낸다.  

클라이언트 소켓 주소에 있는 포트는 클라이언트가 연결 요청을 할 때 커널에 의해 자동으로 배정되며, 이는 ephmeral port 단기 포트라고 알려져 있다. 그러나 서버 소켓 주소에 있는 포트는 서비스에 영구적으로 연결되는, 일반적으로 잘 알려진 포트이다. 예를 들어, 웹 서버는 일반적으로 포트 80번을 이용하고, 이메일 서버는 25번 포트를 이용한다. 잘 알려진 포트에 연결된 각 서비스는 대응되는 잘 알려진 서비스 이름이 있다. 예를 들어, 웹 서비스의 잘 알려진 이름은 http이고, 이메일의 잘 알려진 이름은 smtp이다. 잘 알려진 이름과 잘 알려진 포트 사이의 매핑은 `/etc/services`라고 불리는 파일 안에 저장되어 있다.  

커넥션은 양 끝에 있는 점 end point의 소켓 주소에 의해 고유하게 식별된다. 소켓 주소의 쌍은 socket pair라고 알려져 있으며 튜플 (cliaddr:cliport, servaddr:servport)로 표현된다. 여기서 cliaddr은 클라이언트의 IP 주소이고, cliport는 클라이언트의 포트이고, servaddr은 서버의 IP 주소이고, servport는 서버의 포트이다. 예를 들어, 사진은 웹 클라이언트와 웹 서버 사이의 연결을 보여준다.  

예시에서 웹 클라이언트의 소켓 주소는 `128.2.194.242:51213`이다. 포트 51213은 커널에 의해 배정된 단기 포트이다. 웹 서버의 소켓 주소는 208.216.181.15:80이다.

> 인터넷의 유래  
인터넷은 정부, 대학 그리고 산업의 함께 만들어낸 것 중에 가장 성공적인 예시 중 하나이다. 인터넷의 성공에는 많은 요인이 기여했지만, 우리는 두 가지가 특히 중요하다고 생각한다. 미국 정부의 30년의 지속적인 지원과 MIT의 Dave Clarke가 "거친 합의와 working code"라고 별명을 붙인 열정적인 연구자의 헌신이다.   

인터넷의 씨앗은 1957년에 심어졌다. 이는 냉전의 정점이었던 때로 소련 연합이 첫 인공 위성인 스푸트니크 호를 발사시켜 세상을 깜짝 놀라게 만들었던 때이다. 이에 대한 대응으로 미국 정부는 Advanced Research Projects Agency (ARPA)를 만들었다. 이 기관이 내걸었던 목표는 미국을 과학과 기술 분야에서 선두 국가로 재정립하는 것이었다. 1967년에 ARPA의 Lawrence Roberts는 ARPANET라고 불리는 새로운 네트워크를 위한 계획을 발표했다. 1969년까지 첫 번째 ARPANET 노드가 생겨났고 동작했다. 1971년까지 13개의 ARPANET 노드가 있었고, 이메일이 첫 번째 중요한 네트워크 응용 프로그램으로 등장했다.  

1972년 Robert Kahn은 인터네트워킹의 일반적인 원칙을 다음과 같이 요약했다: 상호 연결된 네트워크의 집합으로 네트워크 간의 통신은 "라우터"라고 불리는 블랙 박스에 의해 "최선의 방법"으로 독립적으로 처리된다. 1974년에 Kahn과 Vinton Cerf는 TCP/IP에 대해 첫 번째로 자세한 내용을 발표했다. 이는 1982년에 ARPANET의 표준 인터네트워킹 프로토콜이 되엇다. 1983년 1월 1일 APARNET의 모든 노드는 TCP/IP로 교체했다. 이는 글로벌 IP 인터넷의 탄생이 되었다. 

1985년에 Paul Mockapertris는 DNS을 발명했고, 1,000개 이상의 인터넷 호스트가 있었다. 다음 해에 National Science Foundation (NSF)는 56Kb/s의 전화선으로 13개의 사이트를 연결해서 NSFNET 근간을 구축하였다. 이는 1988년에 1.5Mb/s 속도의 T1 링크로 업그레이드되었고 1991년에 45Mb/s의 T3 링크로 업그레이드되었다. 1988년까지 50,000 개 이상의 호스트가 있었다. 1989년에 처음의 ARPANET은 이제 공식적으로 은퇴했다. 1995년에 거의 10,000,000 개의 인터넷 호스트가 있었을 때, NSF는 NSFNET을 은퇴시켰고 그것을 사적 상업 근가에 기반을 둔, 공공 네트워크 접근점들에 의해 연결된 현대 인터넷 아키텍처로 교체되었다. 