우리는 네트워크 프로그래밍에 대한 논의를 TINY라고 불리는, 작지만 실용적인 웹 서버를 개발함으로써 종결짓겠다. TINY는 흥미로운 프로그램이다. 이는 우리가 배운 많은 아이디어들, 프로세스 컨트롤, Unix I/O, 소켓 인터페이스, HTTP 등을 250 줄 안에 합친다. 실제 서버의 기능, robustness, 보안은 부족하지만, TINY는 실제 웹 브라우저에게 정적, 동적 콘텐츠 모두를 서비스하기에는 충분히 강력하다. TINY를 공부해서 스스로 구현해볼 것을 권장한다. 당신만의 서버에서 실제 브라우저에서 실제 브라우저를 point하고, 텍스트와 그래픽이 있는 복잡한 웹 페이지를 출력하는 것을 보는 것은 흥미로운 일이다.

#### TINY 메인 루틴

코드 11.29는 TINY의 메인 루틴을 보여준다. TINY는 명령줄에 전달된 포트 번호로 오는 연결 요청을 듣는 반복적인 서버이다. `open_listenfd` 함수를 호출함으로써 listening socket을 연 후에, TINY는 일반적인 무한 서버 루프를 실행시키고, 반복적으로 연결 요청을 수락하고 (라인 32), 상호작용을 수행하고 (라인 36), 연결의 끝을 종료시킨다 (라인 37).

#### doit 함수

코드 11.30에 있는 doit 함수는 하나의 HTTP 상호작용을 처리한다. 첫째, 우리는 요청 라인 (라인 11-14)을 읽고 파싱한다. 우리가 요청 라인을 읽기 위해 도표 10.8로부터 `rio_readlineb` 함수를 사용한다는 점을 기억하라.

TINY는 GET 메서드만을 지원한다. 만약 클라이언트가 POST와 같은 다른 메서드를 요청한다면, 에러 메시지를 보내고 메인 루틴으로 돌아갈 것이다. (라인 15-19), 그 다음에 연결을 닫고 다음 연결 요청을 기다릴 것이다. 그렇지 않다면, 우리는 읽고 다른 요청 헤더를 무시할 것이다. (라인 20)  

다음에, 우리는 URI를 파일 이름과 아마 비어 있는 CGI 인자 문자열로 파싱하고, 요청이 정적 콘텐츠인지 동적 콘텐츠인지를 가리키는 플래그를 설정할 것이다. (라인 23) 만약 파일이 디스크에 존재하지 않는다면, 우리는 즉시 클라이언트에게 메시지를 전송하고 리턴할 것이다.  

마침내, 만약 요청이 정적 콘텐츠에 대한 것이라면, 우리는 파일이 일반 파일이고 우리가 읽기 권한을 가졌다 (line 31)는 것을 입증할 것이다. 만약 입증이 됐다면 클라이언트에게 정적 콘텐츠를 서비스할 것이다. (라인 36) 비슷하게, 요청이 동적 콘텐츠에 대한 것이라면, 우리는 파일이 실행가능한 파일임을 입증한 다음에 입증이 되면 동적 콘텐츠를 서비스할 것이다. (라인 44)

#### clienterror 함수

TINY는 실제 서버의 에러 핸들링 함수들을 많이 가지고 있지 않다. 하지만, 명백한 에러는 체크를 하며 이를 클라이언트에게 보고한다. 도표 11.31에 있는 `clienterror` 함수는 클라이언트에게 응답 라인에 적절한 상태 코드와 상태 메시지를 담아, 브라우저의 사용자에게 에러를 설명하는 response body에 담은 HTML 파일과 함께 HTTP 응답을 전송한다.  

HTML 응답은 body에 있는 콘텐츠의 사이즈와 타입을 가리켜야 한다는 점을 기억하라. 따라서, 우리는 HTML 콘텐츠를 단일 문자열로 만들기를 선호한다. 이렇게 하면 사이즈를 쉽게 결정할 수 있따. 또한, 우리가 도표 10.4의 robust rio_written 함수를 사용한다는 점에 주의하라.

#### read_requesthdrs 함수

TINY는 요청 헤더에 있는 아무 정보도 이용하지 않는다. 이는 도표 11.32에 있는 read_requesthers 함수를 호출함으로써 요청 헤더를 단순히 읽고 무시한다. 요청 헤더를 종결시키는 빈 줄이 carriage return과 line feed의 쌍으로 이루어져 있다는 사실을 기억하라. 이는 라인 6에서 체크했다. 

#### parse_uri 함수

TINY는 정적 콘텐츠를 위한 홈 디렉토리가 현재 디렉토리라고 가정하며, 실행 가능한 파일을 위한 홈 디렉토리가 `./cgi-bin`임을 가정한다. cgi_bin 문자열을 포함하고 있는 모든 URI는 동적 콘텐츠에 대한 요청을 나타내는 것으로 간주된다. 기본 파일 이름은 ./home.html이다. 

도표 11.33에 있는 parse_uri 함수는 이러한 정책들을 구현한다. 이 함수는 URI를 파일 이름과 옵션인 CGI 인자 문자열로 파싱한다. 만약 요청이 정적 콘텐츠를 위한 것이라면 (라인 5), 우리는 CGI 인자 문자열을 clear하고 (라인 6), URI를 상대 리눅스 경로로 변환한다. 예를 들면 ./index.html (라인 7-8)이다. 만약 URIrk '/' 문자 (라인 9)로 종료된다면, 우리는 기본 파일 이름을 덧붙인다. (라인 10) 반면에, 요청이 동적 콘텐츠를 위한 것이라면 (라인 13) 우리는 모든 CGI 인자 (라인 14-20)를 추출하고 남아 있는 URI의 부분을 상대 리눅스 파일 이름으로 변환한다. (라인 21-22)


#### serve_static 함수

TINY는 정적 콘텐츠의 다섯 가지 common type을 서비스한다. HTML 파일, unformatted text files, GIF, PNG, JPEG 포맷으로 인코딩된 이미지.  

도표 11.34에 있는 serve_static 함수는 body에 local file의 콘텐츠를 담고 있는 HTTP 응답을 전송한다. 첫째, 우리는 파일 이름에 있는 suffix를 조사함으로써 파일 타입을 알아내고 (라인 7), 응답 라인과 응답 헤더를 클라이언트에게 전송한다. (라인 8-13) 빈 줄은 헤더를 종료시킨다는 점을 다시 기억하라.  

다음으로, 우리는 요청받은 파일의 콘텐츠를 연결된 descriptor fd로 복사함으로써 response body를 전송한다. 여기에 있는 코드는 미묘해서 조심스럽게 공부할 필요가 있다. 라인 18은 읽기를 위해 파일 이름을 열고 descriptor를 얻어온다. 라인 19에서 리눅스 mmap 함수는 요청받은 파일을 가상 메모리 영역으로 매핑한다. mmap에 대한 호출이 파일 srcfd의 첫 번째 filesize 바이트를 srcp 주소에서 시작하는 가상 메모리의 사적인 읽기 전용 영역으로 매핑한다는 9.8절에서의 mmap에 대한 논의를 상기하라.  

한 번 우리가 파일을 메모리로 매핑했다면 우리는 더 이상 descriptor가 필요하지 않다. 따라서 우리는 파일을 닫는다. (20) 이것에 실패한다면 잠재적으로 치명적인 메모리 누수가 유발될 수 있다. 라인 21은 파일에서 클라이언트로의 실제 전달을 수행한다. rio_written 함수는 srcp 위치에서 시작하는 filesize 바이트(이는 물론 요청받은 파일에 매핑되어 있다.)를 클라이언트의 연결된 descriptor로 복사한다. 마침내 라인 22는 매핑된 가상 메모리 영역을 free한다. 이는 잠재적인 치명적인 메모리 누수를 피하기 위해 중요한 부분이다. 

#### serve_dynamic 함수

TINY는 자식 프로세스를 fork하고 자식의 맥락에서 CGI 프로그램을 실행함으로서 모든 유형의 동적 콘텐츠를 서비스한다.  

도표 11.35에 있는 serve_dynamic 함수는 정보적인 Server 헤더와 함께 클라이언트에게 성공을 나타내는 응답 라인을 전송함으로써 시작된다. CGI 프로그램은 응답의 나머지를 전송할 책임이 있다. 이것이 우리가 소망하는 것처럼 robust하지 않다는 것을 기억하라. 왜냐하면 이는 CGI 프로그램이 어떤 에러를 마주할 수도 있다는 가능성을 허용하지 않기 때문이다.  

응답의 첫 번째 부분을 전송한 후에, 우리는 새로운 자식 프로세스를 forkgksek. (라인 11) 자식은 QUERY_STRING 환경 변수를 요청 URI에 있는 CGI 인자로 초기화한다. 실제 서버는 다른 CGO 환경 변수들도 설정한다는 것을 기억하라. 간단하게 하기 위해서 우리는 이 스텝을 생략했다.  

다음에, 자식은 자식의 표준 출력을 연결된 파일 descriptor로 리다이렉트하고 (라인 14), 로드하고 CGI 프로그램을 실행한다 (실행 15). CGI 프로그램이 자식의 맥락에서 실행되기 때문에, CGI 프로그램은 execve 함수를 호출하기 전에 존재하는, 같은 open file과 환경 변수에 대한 접근을 가지고 있다. 따라서 CGI 프로그램이 표준 출력에 작성하는 모든 것은 클라이언트 프로세스에게 직접적으로 간다. 부모 프로세스의 방해 없이. 그런 와중에 부모는 wait에 대한 호출에서 block된다. child가 종료됐을 때 child를 거둘 수 있게 디가리면서 말이다. 