## 1.2 네트워크

클라이언트와 서버는 종종 별개의 호스트에서 실행되고 서로 통신하기 위해 컴퓨터 네트워크의 하드웨어와 소프트웨어 자원을 사용한다. 네트워크는 정교하고 복잡한 시스템이기에 여기에서는 네트워크의 표면적인 부분만을 다뤄볼 것이다. 우리의 목표는 개발자의 관점에서의 네트워크의 개념적인 모델을 제공하는 것이다.

호스트에게 네트워크는 그저 데이터를 위한 소스 source이자 sink(?)로서 서비스를 제공하는, 또 다른 I/O 디바이스일 뿐이다. 사진 11.2에 이것이 잘 나와 있다.  

I/O 버스에 있는 확장 슬롯에 플러그되어 있는 어댑터는 네트워크를 위한 물리 인터페이스를 제공한다. 네트워크로부터 받은 데이터는 어댑터로부터 I/O와 메모리 버스를 지나 메모리 메모리로 복사된다. 이는 일반적으로 DMA 전송으로 복사된다. 비슷하게, 데이터는 메모리에서 네트워크로 복사될 수도 있다.  

물리적으로, 네트워크는 지리적 인접성에 의해 정렬된 계층적 시스템이다. 가장 낮은 레벨은 LAN (local area network)이다. LAN은 빌딩이나 캠퍼스에 퍼져 있다. 가장 인기 있는 LAN 기술은 지금까지 Ethernet이다. Ethernet은 1970년대 중반에 Xerox PARC에서 개발되었다. Ethernet은 상당히 회복력이 좋다고 증명되어 있다. 이는 3 Mb/s에서 10 Gb/s로 진화했다.  

Ethernet 세그먼트는 몇몇 전선 (일반적으로 꼬여 있는 한 쌍의 전선)과 허브 hub라고 불리는 작은 박스로 이루어져 있다. Ethernet 세그먼트는 일반적으로 작은 방이나 건물의 한 층과 같이 작은 지역에 퍼져 있다. 각각의 전선은 동일한 최대 비트 대역폭 bit bandwidth를 가진다. 일반적으로 100Mb/s 또는 1Gb/s이다. (전선의) 한쪽 끝은 호스트에 있는 어댑터에 연결되어 있고, 나머지 한쪽은 허브에 있는 포트에 연결되어 있다. 허브는 각각의 포트에서 받은 모든 비트를 반대쪽의 모든 포트로 복사한다. 따라서 모든 호스트는 모든 비트를 볼 수 있게 된다.   

각각의 Ethernet 어댑터는 어댑터에 있는 비휘발성 메모리에 저장되어 있는 전역적으로 고유한 48 비트 주소를 가진다. 호스트는 프레임 frame이라고 불리는 비트의 덩어리를 세그먼트에 있는 다른 호스트들에게 전송할 수 있다. 각각의 프레임은 프레임의 출발지 source와 도착지 destination, 프레임의 길이를 식별할 수 있는, 고정된 숫자의 헤더 header 비트들을 포함하고 있다. 이들 뒤에는 페이로드 payload 비트가 온다. 모든 호스트 어댑터는 이 프레임을 볼 수 있지만, 도착지의 호스트만이 이 프레임을 읽어들인다.   

여러 개의 Ethernet 세그먼트는 더 큰 LAN들에 연결될 수 있다. 이렇게 구성된 더 큰 LAN은 브릿지형 이더넷 bridged Ethernets라고 불리는데, 이는 전선들과 브릿지 bridges라고 불리는 작은 박스들을 사용한다. 브릿지형 이더넷은 건물 전체나 캠퍼스 전체에 퍼져 있을 수 있다. 브릿지형 이더넷에서, 몇몇의 전선은 브릿지와 브릿지를 연결하고, 다른 몇몇은 브릿지를 허브에 연결한다. 전선의 대역폭은 서로 다를 수 있다. 우리의 예시에서, 브릿지와 브릿지를 연결하는 전선은 1Gb/s 대역폭을 가지고, 허브와 브릿지를 연결하는 4개의 전선은 100 Mb/s의 대역폭을 가진다.  

브릿지들은 허브와 비교했을 때 사용 가능한 전선을 더 잘 사용한다. (브릿지는 허브보다 더 높은 전선의 대역폭을 가진다.) 기발한 분산 알고리즘 distributed algorithm을 사용해서, 브릿지들은 어떤 포트에서 어떤 호스트가 접근 가능한지를 자동으로 장기간에 걸쳐 학습하고, 그 후에 필요하다면 하나의 포트에서 다른 포트로 프레임을 복사한다. 예를 들어, 만약에 호스트 A가 같은 세그먼트에 있는 호스트 B로 프레임을 전송한다면, 브릿지 X는 자신의 입력 포트에 프레임이 도착할 때 그것을 버릴 것이다. 다른 세그먼트에 있는 대역폭을 절약하기 위해서이다. 하지만 만약 호스트 A가 다른 세그먼트에 있는 호스트 C에게 프레임을 전송한다면, 브릿지 X는 프레임을 호스트 C의 세그먼트에 연결된 포트에만 프레임을 복사할 브릿지 Y에 연결된 포트로만 복사할 것이다. 

> Internet vs internet
우리는 일반적인 개념을 가리킬 때는 항상 소문자 internet이라는 용어를 사용할 것이다. 대문자 Internet은 소위 global IP Internet이라는 특정 구현물을 가리킬 때 사용할 것이다.


LAN 이미지를 간단하게 하기 위해서, 서로를 연결하는 허브와 브리지, 전선을 하나의 수평선에 그릴 것이다.  

계층의 높은 레벨에서, 다수의 비호환 LAN은 internet(상호 연결 네트워크 interconnected network)을 형성하기 위해 라우터 routers라고 불리는 특별한 컴퓨터에 의해 연결될 수 있다. 각각의 라우터는 자신이 연결되어 있는 네트워크에 연결되어 있는 어댑터(포트)가 있다. 라우터들은 고속의 point-to-point 전화 연결을 할 수 있다. 이는 WAN(wide area networks)이라고 알려진 네트워크의 예이다. WAN은 LAN보다 지리적으로 더 넓은 영역에 퍼져 있기 때문에 그러한 이름으로 불리는 것이다. 일반적으로 라우터는 임의의 LAN과 WAN들로부터 인터넷을 만들기 위해 사용될 수 있다. 예를 들어, 사진 11.6에서 3개의 라우터에 의해 연결된 LAN과 WAN의 쌍을 가진 인터넷을 볼 수 있다.  

인터넷의 중요한 특징은 인터넷이 매우 다르고 비호환적인 기술을 가지는 여러 가지 LAN과 WAN으로 이루어질 수 있다는 것이다.(?) 각각의 호스트는 물리적으로 다른 모든 호스트들과 연결되어 있다. 그런데 모든 비호환 네트워크를 지나서 어떤 source host가 다른 destination host에게 데이터 비트를 전송하는 것은 어떻게 가능한 것일까?  

이는 서로 다른 네트워크 사이의 격차를 없애주는, 호스트와 라우터에서 실행 중인 포로토콜 소프트웨어 protocol software의 계층 layer 덕분에 가능한 것이다. 이 소프트웨어는 호스트와 라우터가 데이터를 전송하기 위해서 어떻게 협력하는지를 통제하는 프로토콜 protocol을 구현한다. 이 프로토콜은 두 가지 기본 기능을 제공해야 한다.  

- Naming scheme. 명명법.   
다양한 LAN 기술은 서로 다르고 비호환되는, 호스트에게 주소를 배정하는 방법을 가지고 있다. 인터넷 프로토콜 internet protocol은 호스트 주소를 위한 통일된 형식을 정의함으로써 이러한 격차를 없앤다. 각 호스트들은 자신을 고유하게 식별하는 인터넷 주소를 적어도 하나 배정받게 된다.

- Delivery mechanism. 전달 기법.
서로 다른 네트워킹 기술들은 서로 다른 비호환적인, 전선에서의 비트를 인코딩하는 방법 그리고 이러한 비트들을 프레임 frame으로 패키징하는 방법을 가지고 있다. 인터넷 프로토콜은 데이터 비트를 패킷 packet이라고 불리는 분리된 덩어리로 묶는 통일된 방법을 정의함으로써 이러한 차이를 없앤다. 패킷은 헤더 header(헤더는 패킷 사이즈와 source hosts, destination hosts를 포함하고 있다.)와 페이로드 payload(source host가 보낸 데이터 비트)를 포함하고 있다. 

사진 11.7은 호스트와 라우터가 비호환 LAN들을 건너서 어떻게 데이터를 전송하기 위해서 어떻게 인터넷을 이용하는지 하나의 예를 보여준다. 이 예시 인터넷은 라우터에 의해 연결된 2개의 LAN으로 이루어져 있다. LAN 1에 연결된 host A에서 운영 중인 클라이언트는 LAN 2에 연결된 host B에서 운영 중인 서버에게 데이터 바이트의 시퀀스를 전송한다. 여기에는 8가지 기본 단계가 있다.  

1. 호스트 A에 있는 클라이언트는 시스템 콜을 호출한다. 이 시스템 콜은 클라이언트의 가상 주소 공간으로부터 커널 버퍼로 데이터를 복사한다.
2. 호스트 A에 있는 프로토콜 소프트웨어는 데이터에 인터넷 헤더와 LAN 1 헤더를 덧붙임으로써 LAN 1 프레임을 생성한다. 인터넷 헤더는 받는 사람으로 인터넷 호스트 B를 지정한다. LAN 1 프레임 헤더는 라우터를 받는 사람으로 지정한다. 프로토콜 소프트웨어는 그 다음 프레임을 어댑터에게 전달한다. 이때 LAN 1 프레임의 페이로드는 인터넷 패킷이고, 이 패킷의 페이로드는 실제 사용자의 데이터라는 점에 주목해야 한다. 이러한 캡슐화 encapsulation은 인터 네트워킹 internetworking과 관련하여 기본적인 통찰 중 하나이다.
3. LAN 1 어댑터는 네트워크로 프레임을 복사한다.
4. 프레임이 라우터에 도달하면, 라우터의 LAN 1 어댑터는 전선으로부터 프레임을 읽어들여서 프로토콜 소프트웨어에게 전달한다.
5. 라우터는 인터넷 패킷 헤더로부터 도착 인터넷 주소 정보를 얻어오고, 이 정보를 라우팅 테이블 routing table에 있는 인덱스로서 사용하여 패킷을 어디로 보낼지를 결정한다. 우리의 예시에서는 LAN 2로 패킷을 보낼 것이다. 라우터는 그 다음에 이전 LAN 1 프레임 헤더를 벗겨 내고, 호스트 B를 받는 사람으로 설정한 새로운 LAN 2 프레임 헤더를 앞에 붙인다. 그리고 완성된 프레임을 어댑터에게 전송한다.
6. 라우터의 LAN2 어댑터는 프레임을 네트워크에게 복사한다.
7. 프레임이 호스트 B에 도달하면, 호스트 B의 어댑터는 전선으로부터 프레임을 읽어들여서 프레임을 프로토콜 소프트웨어에게 전달한다.
8. 최종적으로, 호스트 B에 있는 프로토콜 소프트웨어는 패킷 헤더와 프레임 헤더를 벗겨 낸다. 프로토콜 소프트웨어는 마침내 서버가 데이터를 읽어들이는 시스템 콜을 호출했을 때, 결과 데이터를 서버의 가상 주소 공간으로 복사할 수 있다. 

물론 우리는 여기에서 많은 어려운 이슈들을 얼버무려서 이야기하고 있다. 만약 다른 네트워크들이 다른 최대 프레임 사이즈 maximum frame size를 가지고 있다면 어떻게 해야 할까? 라우터들은 프레임을 어디로 보내야 할지 어떻게 알 수 있을까? 네트워크 토폴로지가 변화했을 때 라우터들은 어떻게 이 변화를 알 수 있을까? 패킷이 손실되면 어떻게 해야 할까? 그럼에도 불구하고 우리의 예시는 인터넷이라는 아이디어를 담고 있고, 캡슐화라는 것이 핵심이다.
